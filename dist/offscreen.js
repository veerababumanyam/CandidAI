(()=>{"use strict";const e=("undefined"!=typeof chrome&&chrome.offscreen&&(chrome.offscreen.Reason.USER_MEDIA,chrome.offscreen.Reason.AUDIO_PLAYBACK),{OPENAI:{name:"OpenAI",baseUrl:"https://api.openai.com/v1",models:["gpt-4","gpt-4-turbo","gpt-3.5-turbo"],maxTokens:4096,rateLimits:{requestsPerMinute:60,tokensPerMinute:9e4,dailyLimit:1e6}},ANTHROPIC:{name:"Anthropic",baseUrl:"https://api.anthropic.com/v1",models:["claude-3-opus","claude-3-sonnet","claude-3-haiku"],maxTokens:4096,rateLimits:{requestsPerMinute:50,tokensPerMinute:4e4,dailyLimit:5e5}},GOOGLE:{name:"Google",baseUrl:"https://generativelanguage.googleapis.com/v1",models:["gemini-pro","gemini-pro-vision"],maxTokens:2048,rateLimits:{requestsPerMinute:60,tokensPerMinute:32e3,dailyLimit:1e6}}}),s=(e.OPENAI.baseUrl,e.OPENAI.rateLimits,e.ANTHROPIC.baseUrl,e.ANTHROPIC.rateLimits,{timeout:3e4,retryAttempts:3,retryDelay:1e3,enableLogging:!0});class t{config;handlers=new Map;pendingRequests=new Map;constructor(e={}){this.config={...s,...e},this.initializeMessageListener()}initializeMessageListener(){"undefined"!=typeof chrome&&chrome.runtime&&chrome.runtime.onMessage?chrome.runtime.onMessage.addListener(((e,s,t)=>(this.handleIncomingMessage(e,s,t).catch((e=>{console.error("Error handling incoming message:",e),t({success:!1,error:e instanceof Error?e.message:"Unknown error"})})),!0))):console.warn("Chrome extension APIs not available in this environment")}async handleIncomingMessage(e,s,t){const{command:r}=e;this.config.enableLogging&&console.log(`[MessageBroker] Received command: ${r}`,e);const a=this.handlers.get(r);if(a)try{await a(e,s,t)}catch(e){const s=e instanceof Error?e.message:"Unknown error";console.error(`Error in handler for command ${r}:`,e),t({success:!1,error:s})}else t({success:!1,error:"Unknown command",details:`No handler registered for command: ${r}`})}registerHandler(e,s){this.handlers.has(e)&&console.warn(`[MessageBroker] Overwriting existing handler for command: ${e}`),this.handlers.set(e,s),this.config.enableLogging&&console.log(`[MessageBroker] Registered handler for command: ${e}`)}unregisterHandler(e){const s=this.handlers.delete(e);return this.config.enableLogging&&s&&console.log(`[MessageBroker] Unregistered handler for command: ${e}`),s}async sendMessage(e,s){const t={...e,requestId:this.generateRequestId(),timestamp:Date.now()};return this.config.enableLogging&&console.log("[MessageBroker] Sending message:",t),this.sendMessageWithRetry(t,s,0)}async sendMessageWithRetry(e,s,t){try{return await this.sendSingleMessage(e,s)}catch(r){if(t<this.config.retryAttempts)return this.config.enableLogging&&console.warn(`[MessageBroker] Retry attempt ${t+1} for message:`,e.command),await this.delay(this.config.retryDelay*(t+1)),this.sendMessageWithRetry(e,s,t+1);throw r}}async sendSingleMessage(e,s){return new Promise(((t,r)=>{const a=setTimeout((()=>{r(new Error(`Message timeout after ${this.config.timeout}ms`))}),this.config.timeout),i=e=>{clearTimeout(a),chrome.runtime.lastError?r(new Error(chrome.runtime.lastError.message)):e?t(e):r(new Error("No response received"))};try{if("undefined"==typeof chrome||!chrome.runtime)return clearTimeout(a),void r(new Error("Chrome extension APIs not available"));s?chrome.tabs.sendMessage(s,e,i):chrome.runtime.sendMessage(e,i)}catch(e){clearTimeout(a),r(e)}}))}async sendMessageToTab(e,s){return this.sendMessage(s,e)}async sendCommand(e,s){const t={command:e,data:s,timestamp:Date.now()};return this.sendMessage(t)}async sendMessageToServiceWorker(e){return this.sendMessage({...e,target:"service_worker"})}async sendMessageToContentScript(e,s){return this.sendMessageToTab(e,{...s,target:"content_script"})}async broadcastMessage(e){try{const s=(await chrome.tabs.query({})).filter((e=>void 0!==e.id)).map((s=>this.sendMessageToTab(s.id,e).catch((()=>null))));return(await Promise.all(s)).filter((e=>null!==e))}catch(e){return console.error("Error broadcasting message:",e),[]}}generateRequestId(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}delay(e){return new Promise((s=>setTimeout(s,e)))}getRegisteredHandlers(){return Array.from(this.handlers.keys())}clearHandlers(){this.handlers.clear(),this.config.enableLogging&&console.log("[MessageBroker] All handlers cleared")}getStats(){return{handlersCount:this.handlers.size,pendingRequestsCount:this.pendingRequests.size}}}class r{messageBroker;audioState;constructor(){this.messageBroker=new t,this.audioState={isRecording:!1,mediaRecorder:null,audioStream:null,audioChunks:[]},this.initializeMessageHandlers()}initializeMessageHandlers(){this.messageBroker.registerHandler("START_AUDIO_CAPTURE",this.startAudioCapture.bind(this)),this.messageBroker.registerHandler("STOP_AUDIO_CAPTURE",this.stopAudioCapture.bind(this)),this.messageBroker.registerHandler("PING",this.handlePing.bind(this))}async startAudioCapture(e,s,t){try{if(this.audioState.isRecording)return void t({success:!1,error:"Already recording"});const e=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:!0,noiseSuppression:!0,autoGainControl:!0}});this.audioState.audioStream=e,this.audioState.mediaRecorder=new MediaRecorder(e,{mimeType:"audio/webm;codecs=opus"}),this.audioState.audioChunks=[],this.audioState.mediaRecorder.ondataavailable=e=>{e.data.size>0&&this.audioState.audioChunks.push(e.data)},this.audioState.mediaRecorder.onstop=()=>{this.processAudioData()},this.audioState.mediaRecorder.onerror=e=>{console.error("MediaRecorder error:",e),this.stopAudioCapture(null,null,(()=>{}))},this.audioState.mediaRecorder.start(1e3),this.audioState.isRecording=!0,t({success:!0,message:"Audio capture started"})}catch(e){console.error("Failed to start audio capture:",e),t({success:!1,error:e instanceof Error?e.message:"Failed to start audio capture"})}}stopAudioCapture(e,s,t){try{if(!this.audioState.isRecording)return void t({success:!1,error:"Not recording"});this.audioState.mediaRecorder&&"inactive"!==this.audioState.mediaRecorder.state&&this.audioState.mediaRecorder.stop(),this.audioState.audioStream&&(this.audioState.audioStream.getTracks().forEach((e=>e.stop())),this.audioState.audioStream=null),this.audioState.isRecording=!1,this.audioState.mediaRecorder=null,t({success:!0,message:"Audio capture stopped"})}catch(e){console.error("Failed to stop audio capture:",e),t({success:!1,error:e instanceof Error?e.message:"Failed to stop audio capture"})}}async processAudioData(){try{if(0===this.audioState.audioChunks.length)return;const e=new Blob(this.audioState.audioChunks,{type:"audio/webm"}),s=await e.arrayBuffer();await this.messageBroker.sendMessage({command:"PROCESS_AUDIO_DATA",payload:{audioData:Array.from(new Uint8Array(s)),timestamp:Date.now(),mimeType:"audio/webm"}}),this.audioState.audioChunks=[]}catch(e){console.error("Failed to process audio data:",e)}}handlePing(e,s,t){t({success:!0,message:"Offscreen document is active",timestamp:Date.now()})}initialize(){console.log("CandidAI Offscreen document initialized"),this.messageBroker.sendMessage({command:"OFFSCREEN_READY",payload:{timestamp:Date.now()}}).catch((e=>{console.error("Failed to notify service worker:",e)}))}}"loading"===document.readyState?document.addEventListener("DOMContentLoaded",(()=>{(new r).initialize()})):(new r).initialize()})();